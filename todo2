---
Get rid of numpad keybindings
ctrl + tab -> change active tab
---
Did I brake bold font support for 3.18?
---
Search box animation doesnt feel good. Maybe get rid of it entirely. Simplify.
Search Box and cursor? And why is the mouse pointer disappearing?
---
Fix @@!
---
ctrl[ + shift] + left/right

When dealing with source code (not plain text):
	word (alphabetic characters, digits, underscores) vs non-word (everything else)
	example words: cat, cat123, 123, _cat, _cat123
	123
	1.23
	0xab
	1.2e1

FORWARD:
middle/start -> end
end -> end next
outside -> end

BACKWARD:
middle/end -> start
start -> start previous
outside -> start

what is a word? (alphabetic, digits, underscores)

ctrl + left/right -- jump

---

mouse selection:

1BUTTON_PRESS -> place cursor
2BUTTON_PRESS -> select word/non-word
3BUTTON_PRESS -> select line

Before user releases the button, we are in a selection mode. The type of selection mode depends on the type of button press:
	1BUTTON_PRESS -> expand by character
	2BUTTON_PRESS -> expand by word/non-word
	3BUTTON_PRESS -> expand by line

The selection is between the initial selection and the mouse (if mouse moves over a word, the selection is expanded by that word)
The cursor is always on the side closer to the beginning of the buffer.

Honestly, I didnt even know about the different modes of selection until I started looking at the way it is designed by GTK very carefully. So is it important to do it exactly this way? Even if it means more or more complicated code? I dont think so.

If I want to select precise characters, I can use a mouse to do it, but updating a selection by word or by line is not important. (?)

Sublime also does that.

---

/*
return value: TRUE/FALSE, whether it found the boundry or hit the end of buffer
*/
gboolean next_word_boundry(GtkTextIter *iter, GtkTextBuffer *buffer)

---

imagine I could filter files and directories in file browser. say, switch off directories, or, switch on .cpp files and .hpp files. and it would be really easy. you just toggle some buttons. and you can define your own button based on simple rules. would that be a cool feature?

---

Jump to a function definition. A function definition in where? Internet? Local partition? So we arrive at an idea of a project. It limits the scope of our responsibilities.

We can think of a project as a list of files. And then we predigest data in these files into some helpful data structures which are going to make searching for function definitions, type definitions etc. super fast. What if we updated them every time new data is saved on disk? Just parse everything all over again? Sounds very simple, but how slow is it gonna get?

Can a project be thought of as a directory? Just a branch of a filesystem tree? We already have a file browser. So what if it was possible to just click on a directory or a file and select "make this into a C++ project" or "make this into a HTML, CSS, JS project" or "make this into my custom whatver project". For "C++ project" you would maybe write code that parses throught .cpp or .cxx etc. files. But really anything you can do with a directory or a file could happen.